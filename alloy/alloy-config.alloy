/* Grafana Alloy Configuration Examples
 * ---
 * LINK: For more details, visit https://github.com/grafana/alloy-scenarios
*/

// ! ====================== TARGETS

loki.write "default" {
	endpoint {
		url = "http://loki:3100/loki/api/v1/push"
	}
	external_labels = {}
}

prometheus.remote_write "default" {
	endpoint {
		url = "http://prometheus:9090/api/v1/write"
	}
}



// ! ====================== SYSTEM LOGS & JOURNAL

// ! NOTES, FOR WINDOWS OR WSL BASED TRYING USING NATIVE DOCKER, PLEASE COMMENT OUT THE JOURNAL SOURCE BELOW
// ! AS IT WILL CAUSE ERROR IF SYSTEMD JOURNAL NOT AVAILABLE
loki.source.journal "journal" {
	max_age       = "24h0m0s"
	relabel_rules = discovery.relabel.journal.rules
	forward_to    = [loki.write.default.receiver]
	labels        = {component = string.format("%s-journal", constants.hostname)}
	// NOTE: This is important to fix https://github.com/grafana/alloy/issues/924
	path          = "/var/log/journal" 
}

local.file_match "system" {
	path_targets = [{
		__address__ = "localhost",
		__path__    = "/var/log/{syslog,messages,*.log}",
		instance    = constants.hostname,
		job         = string.format("%s-logs", constants.hostname),
	}]
}

discovery.relabel "journal" {
	targets = []
	rule {
		source_labels = ["__journal__systemd_unit"]
		target_label  = "unit"
	}
	rule {
		source_labels = ["__journal__boot_id"]
		target_label  = "boot_id"
	}
	rule {
		source_labels = ["__journal__transport"]
		target_label  = "transport"
	}
	rule {
		source_labels = ["__journal_priority_keyword"]
		target_label  = "level"
	}
}

loki.source.file "system" {
	targets    = local.file_match.system.targets
	forward_to = [loki.write.default.receiver]
}



// ! ======================  SYSTEM METRICS

discovery.relabel "metrics" {
	targets = prometheus.exporter.unix.metrics.targets
	rule {
		target_label = "instance"
		replacement  = constants.hostname
	}
	rule {
		target_label = "job"
		replacement = string.format("%s-metrics", constants.hostname)
	}
}

prometheus.exporter.unix "metrics" {
	disable_collectors = ["ipvs", "btrfs", "infiniband", "xfs", "zfs"]
	enable_collectors = ["meminfo"]
	filesystem {
		fs_types_exclude     = "^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|tmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
		mount_points_exclude = "^/(dev|proc|run/credentials/.+|sys|var/lib/docker/.+)($|/)"
		mount_timeout        = "5s"
	}
	netclass {
		ignored_devices = "^(veth.*|cali.*|[a-f0-9]{15})$"
	}
	netdev {
		device_exclude = "^(veth.*|cali.*|[a-f0-9]{15})$"
	}
}

prometheus.scrape "metrics" {
scrape_interval = "15s"
	targets    = discovery.relabel.metrics.output
	forward_to = [prometheus.remote_write.default.receiver]
}



// ! ======================: DOCKER METRICS

prometheus.exporter.cadvisor "dockermetrics" {
	docker_host = "unix:///var/run/docker.sock"
	storage_duration = "5m"
}

prometheus.scrape "dockermetrics" {
	targets    = prometheus.exporter.cadvisor.dockermetrics.targets
	forward_to = [ prometheus.remote_write.default.receiver ]
	scrape_interval = "10s"
}



// ! ======================
// ! notes:  DOCKER LOGS FOR "CATCH ALL" NOT REALLY RECOMMENDED BECAUSE CAN CAUSE TOO NOISY IN LOGS
discovery.docker "dockerlogs" {
  host = "unix:///var/run/docker.sock"
}

discovery.relabel "dockerlogs" {
      targets = []

      rule {
          source_labels = ["__meta_docker_container_name"]
        //   regex = "/(.*)"
          target_label = "service_name"
      }

  }

loki.source.docker "default" {
  host       = "unix:///var/run/docker.sock"
  targets    = discovery.docker.dockerlogs.targets
  labels     = {"platform" = "docker"}
  relabel_rules = discovery.relabel.dockerlogs.rules
  forward_to = [loki.write.default.receiver]
}

// ! ====================== SPECIFIC MONITORING FOR per CONTAINER LOGS MONITORING
// ! IF YOU WANT TO MONITOR SPECIFIC CONTAINER, UNCOMMENT THE EXAMPLE BELOW AND MODIFY IT AS NEEDED

// ! EXAMPLE OF FIBER APP CUSTOM EXTRACT CUSTOM LOG
// discovery.relabel "LABEL_APP_NAME_HERE" {
// 	targets = []

//     rule {
//         source_labels = ["__meta_docker_container_name"]
//         target_label  = "container_name"
//     }

//     rule {
// ! recommendation to JUST add it to one "specific" label if you also using the "CATCH ALL" docker container setup above, this approach can make literal difference label setup like at "service" label will be all logs from docker that just raw log and the specific you parsing like this one will be at label "service_custom_full_log" will be help to found the "custom parsing" logs that we monitored
//         target_label = "service_custom_full_log"
//         replacement  = "LABEL_APP_NAME_HERE_APPEAR_IN_GRAFANA"
//     }
// }

// discovery.docker "LABEL_APP_NAME_HERE" {
//     host             = "unix:///var/run/docker.sock"
//     refresh_interval = "5s"

//     filter {
//         name   = "name"
//         values = ["CONTAINER_NAME"]
//     }
// }

// loki.source.docker "LABEL_APP_NAME_HERE" {
//     host       = "unix:///var/run/docker.sock"
//     targets    = discovery.docker.LABEL_APP_NAME_HERE.targets
//     forward_to = [loki.process.LABEL_APP_NAME_HERE.receiver]

//     relabel_rules = discovery.relabel.LABEL_APP_NAME_HERE.rules
// }

// loki.process "LABEL_APP_NAME_HERE" {
//     forward_to = [loki.write.default.receiver]

//     stage.regex {
//         expression = "^(?P<timestamp>\\d{2}:\\d{2}:\\d{2}) \\| (?P<status_code>\\d{3}) \\| +(?P<latency>[\\d\\.]+[Âµmsnhd]+) \\| (?P<client_ip>[\\d\\.]+) \\| (?P<method>\\w+) \\| (?P<path>[^|]+) \\| ?(?P<message>.*?)$"
//     }

//     stage.regex {
//         expression = "^(?P<timestamp>\\d{2}:\\d{2}:\\d{2}) (?P<raw_message>.*)"
//     }

//     stage.labels {
//         values = {
//             status_code = "",
//             method      = "",
//             level       = "",
//         }
//     }
    
//     stage.structured_metadata {
//         values = {
//             latency   = "latency",
//             path      = "path",
//             client_ip = "client_ip",
//             message   = "message",
// 			status_code = "status_code",
// 			method = "method",
//         }
//     }

//     stage.template {
//         source   = "level"
//         template = `{{ if .status_code }}{{ if ge .status_code "500" }}error{{ else if ge .status_code "400" }}warn{{ else if ge .status_code "300" }}info{{ else }}debug{{ end }}{{ else }}info{{ end }}`
//     }

//     stage.static_labels {
//         values = {
//             app         = "APP-NAME-HERE",
//             log_type    = "access",
//             environment = "testing",
//         }
//     }
// }

